theme(axis.title.y=element_text(vjust=0.3)) +
theme(title=element_text(vjust=1.5)) +
theme(axis.text.x=element_text(size=14))
brewerplot <- function (palette) {
p + scale_fill_brewer(palette = palette) + opts(title=palette)
}
brewerplot ("Paired")
quartz(width=3,height=4,title = "Learner")
p <- qplot(Learner, Proportion.of.naming.events,
data=subset(d_ja, d_ja$chi_env=="child "), fill=Joint_Attention) +
geom_bar(width=0.6) +
ylim(0,1) +
xlab("Type of Learner") +
ylab("Propotion of Naming Events") +
theme_bw() +
theme(axis.title.x=element_text(vjust=-0.5)) +
theme(axis.title.y=element_text(vjust=0.3)) +
theme(title=element_text(vjust=1.5)) +
theme(axis.text.x=element_text(size=14))
brewerplot <- function (palette) {
p + scale_fill_brewer(palette = palette) + opts(title=palette)
}
brewerplot ("Paired")
quartz(width=3,height=4,title = "Learner")
p <- qplot(Learner, Proportion.of.naming.events,
data=subset(d_ja, d_ja$chi_env=="environment"), fill=Joint_Attention) +
geom_bar(width=0.6) +
ylim(0,1) +
xlab("Type of Learner") +
ylab("Propotion of Naming Events") +
theme_bw() +
theme(axis.title.x=element_text(vjust=-0.5)) +
theme(axis.title.y=element_text(vjust=0.3)) +
theme(title=element_text(vjust=1.5)) +
theme(axis.text.x=element_text(size=14))
brewerplot <- function (palette) {
p + scale_fill_brewer(palette = palette) + opts(title=palette)
}
brewerplot ("Paired")
rm(list=ls())
source("/Users/kmacdonald/Documents/Projects/SOC_XSIT/r_scripts/soc_xsit_model.R")
library(bootstrap)
library(lme4)
library(ggplot2)
library(arm)
library(directlabels)
library(stringr)
library(plyr)
library(reshape2)
options(device="quartz")
compute.probs2(gamma=0, lambda=1, sigma=.5, numPic=4, int=0)
compute.probs2(gamma=1, lambda=0, sigma=.5, numPic=4, int=0)
compute.probs2(gamma=1, lambda=1, sigma=.5, numPic=4, int=0)
compute.probs2(gamma=1, lambda=0, sigma=.5, numPic=4, int=10)
compute.probs2(gamma=1, lambda=1, sigma=.5, numPic=4, int=10)
compute.probs2(gamma=1, lambda=1, sigma=0, numPic=4, int=0)
compute.probs2(gamma=1, lambda=1, sigma=.5, numPic=4, int=0)
compute.probs2(gamma=1, lambda=1, sigma=1, numPic=4, int=0)
gamma <- seq(.5,2,.5)           # strength of initial encoding
lambda <- 0                     # rate of memory decay
sigma <- seq(0.25,1,0.25)       # amount of belief given to initial hypothesis
int <- c(0,1,3,7)               # number of intervening words
numPic <- seq(2,8,2)            # number of pics
## generate probabilites for different parameter values (sigma, number of pics, delay)
probs <- data.frame()
for (i in 1:length(int)){
for (n in 1:length(numPic)) {
for (s in 1:length(sigma)) {
for (g in 1:length(gamma)) {
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond ="no-social"))
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond = "social"))
}
}
}
}
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==1)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==2)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
gamma <- seq(.5,2,.5)           # strength of initial encoding
lambda <- 0                     # rate of memory decay
sigma <- 0       # amount of belief given to initial hypothesis
int <- c(0,1,3,7)               # number of intervening words
numPic <- seq(2,8,2)
probs <- data.frame()
for (i in 1:length(int)){
for (n in 1:length(numPic)) {
for (s in 1:length(sigma)) {
for (g in 1:length(gamma)) {
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond ="no-social"))
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond = "social"))
}
}
}
}
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==2)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
gamma <- seq(.5,2,.5)           # strength of initial encoding
lambda <- 0                     # rate of memory decay
sigma <- 1      # amount of belief given to initial hypothesis
int <- c(0,1,3,7)               # number of intervening words
numPic <- seq(2,8,2)            # number of pics
## generate probabilites for different parameter values (sigma, number of pics, delay)
probs <- data.frame()
for (i in 1:length(int)){
for (n in 1:length(numPic)) {
for (s in 1:length(sigma)) {
for (g in 1:length(gamma)) {
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond ="no-social"))
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond = "social"))
}
}
}
}
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==2)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
gamma <- 2                      # strength of initial encoding
lambda <- 0                     # rate of memory decay
sigma <- 1                      # amount of belief given to initial hypothesis
int <- c(0,1,3,7)               # number of intervening words
numPic <- 4
probs <- data.frame()
for (i in 1:length(int)){
for (n in 1:length(numPic)) {
for (s in 1:length(sigma)) {
for (g in 1:length(gamma)) {
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond ="no-social"))
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond = "social"))
}
}
}
}
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==2)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
theta <- function(x,xdata,na.rm=T) {mean(xdata[x],na.rm=na.rm)}
ci.low <- function(x,na.rm=T) {
mean(x,na.rm=na.rm) - quantile(bootstrap(1:length(x),1000,theta,x,na.rm=na.rm)$thetastar,.025,na.rm=na.rm)}
ci.high <- function(x,na.rm=T) {
quantile(bootstrap(1:length(x),1000,theta,x,na.rm=na.rm)$thetastar,.975,na.rm=na.rm) - mean(x,na.rm=na.rm)}
## helper functions
inv.logit <- function(x) {1 / (1 + exp(-x))} # for checking coefficients in glm
## maps levels of variable to
mf_labeller <- function(var, value){
value <- as.character(value)
if (var=="numPicN") {
value[value=="2"] <- "2-Referents"
value[value=="4"] <- "4-Referents"
value[value=="6"] <- "6-Referents"
}
return(value)
}
d <- read.csv("/Users/kmacdonald/Documents/Projects/SOC_XSIT/processed_data/soc_xsit_expt1_all.csv")
## get the test trials only
d.test <- subset(d, testTrial==1)
length(unique(d.test$subid))
## get first trials only
d.first.trial <- subset(d, testTrial==1 & first.trial==TRUE)
length(unique(d.first.trial$subid))
## grab exposure trials only
d.exp <- subset(d, exposureTrial==1)
length(unique(d.exp$subid))
d.exp$faceIdx6 <- revalue(d.exp$face, c("eyes_left_90"=0, "eyes_right_90"=1,
"eyes_left"=2, "eyes_down_left"=3,
"eyes_down_right"=4, "eyes_right"=5,
"eyescenter"=-1))
# flag if subject chose target of eye gaze
# exposure trials left/right midline and on the bottom row
d.exp$choseSocial <- NA
d.exp$imgLocation <- NA
d.exp$imgLocation <- ifelse((d.exp$face == "eyes_right_90") |
(d.exp$face == "eyes_left_90") |
(d.exp$chosenIdx <= 1),
"midline",
"bottom")
d.exp$choseSocial <- ifelse((d.exp$numPic == 6) & (d.exp$condition =="Social"),
d.exp$faceIdx6 == d.exp$chosenIdx,
d.exp$faceIdx == d.exp$chosenIdx)
## get mean chose social by trial type, condition, and sub id
mss.exp <- aggregate(choseSocial ~ trialType + subid + condition + numPicN, data=d.exp, FUN=mean)
ms.exp <- aggregate(choseSocial ~  condition + numPicN, data=d.exp, FUN=mean)
ms.exp$choseSocial.cih <- aggregate(choseSocial ~ condition + numPicN, data=mss.exp, FUN=ci.high)$choseSocial
ms.exp$choseSocial.cil <- aggregate(choseSocial ~ condition + numPicN, data=mss.exp, FUN=ci.low)$choseSocial
# now plot with NumPicF as a factor
ms.exp$numPicF <- as.factor(ms.exp$numPicN)
quartz(width=3,height=4,title = "Experiment 2: Exposure Trials")
p <- ggplot(data=ms.exp, aes(x=numPicF, y=choseSocial)) +
geom_bar(stat="identity", fill="springgreen2") +
geom_errorbar(aes(ymin=choseSocial-choseSocial.cil, ymax=choseSocial+choseSocial.cih),
width=.2,                    # Width of the error bars
position=position_dodge(.9)) +
ylim(0,1) +
xlab("Number of Referents") +
ylab("Proportion Chose Target of Gaze") +
theme_bw()
brewerplot <- function (palette) {
p + scale_fill_brewer(palette = palette) + opts(title=palette)
}
brewerplot ("Paired")
quartz(width=3,height=4,title = "Experiment 2: Exposure Trials")
p <- ggplot(data=ms.exp, aes(x=numPicF, y=choseSocial)) +
geom_bar(stat="identity") +
geom_errorbar(aes(ymin=choseSocial-choseSocial.cil, ymax=choseSocial+choseSocial.cih),
width=.2,                    # Width of the error bars
position=position_dodge(.9)) +
ylim(0,1) +
xlab("Number of Referents") +
ylab("Proportion Chose Target of Gaze") +
theme_bw()
brewerplot <- function (palette) {
p + scale_fill_brewer(palette = palette) + opts(title=palette)
}
brewerplot ("Paired")
brewerplot <- function (palette) {
p + scale_fill_brewer(palette = palette) + opts(title=palette)
}
brewerplot ("Paired")
quartz(width=3,height=4,title = "Experiment 2: Exposure Trials")
<- ggplot(data=ms.exp, aes(x=numPicF, y=choseSocial)) +
geom_bar(stat="identity", fill="deepskyblue2") +
geom_errorbar(aes(ymin=choseSocial-choseSocial.cil, ymax=choseSocial+choseSocial.cih),
width=.2,                    # Width of the error bars
position=position_dodge(.9)) +
ylim(0,1) +
xlab("Number of Referents") +
ylab("Proportion Chose Target of Gaze") +
theme_bw()
quartz(width=3,height=4,title = "Experiment 2: Exposure Trials")
ggplot(data=ms.exp, aes(x=numPicF, y=choseSocial)) +
geom_bar(stat="identity", fill="deepskyblue2") +
geom_errorbar(aes(ymin=choseSocial-choseSocial.cil, ymax=choseSocial+choseSocial.cih),
width=.2,                    # Width of the error bars
position=position_dodge(.9)) +
ylim(0,1) +
xlab("Number of Referents") +
ylab("Proportion Chose Target of Gaze") +
theme_bw()
gamma <- 1.5                      # strength of initial encoding
lambda <- 0.1597503                    # rate of memory decay
sigma <- 1                      # amount of belief given to initial hypothesis
int <- c(0,1,3,7)               # number of intervening words
numPic <- 4                     # number of pics
## generate probabilites for different parameter values (sigma, number of pics, delay)
probs <- data.frame()
for (i in 1:length(int)){
for (n in 1:length(numPic)) {
for (s in 1:length(sigma)) {
for (g in 1:length(gamma)) {
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond ="no-social"))
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond = "social"))
}
}
}
}
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==2)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
gamma <- 1.5                      # strength of initial encoding
lambda <- 0.1597503                    # rate of memory decay
sigma <- 1                      # amount of belief given to initial hypothesis
int <- c(0,1,3,7)               # number of intervening words
numPic <- 4                     # number of pics
## generate probabilites for different parameter values (sigma, number of pics, delay)
probs <- data.frame()
for (i in 1:length(int)){
for (n in 1:length(numPic)) {
for (s in 1:length(sigma)) {
for (g in 1:length(gamma)) {
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond ="no-social"))
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond = "social"))
}
}
}
}
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==1.5)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
gamma <- 1.5                    # strength of initial encoding
lambda <- 0.1597503             # rate of memory decay
sigma <- 1                      # amount of belief given to initial hypothesis
int <- c(0,1,3,7)               # number of intervening words
numPic <- 4                     # number of pics
## generate probabilites for different parameter values (sigma, number of pics, delay)
probs <- data.frame()
for (i in 1:length(int)){
for (n in 1:length(numPic)) {
for (s in 1:length(sigma)) {
for (g in 1:length(gamma)) {
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond ="no-social"))
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond = "social"))
}
}
}
}
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==1.5)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
gamma <- 1.5                    # strength of initial encoding
lambda <- 0.1597503             # rate of memory decay
sigma <- 0.57                      # amount of belief given to initial hypothesis
int <- c(0,1,3,7)               # number of intervening words
numPic <- 4                     # number of pics
## generate probabilites for different parameter values (sigma, number of pics, delay)
probs <- data.frame()
for (i in 1:length(int)){
for (n in 1:length(numPic)) {
for (s in 1:length(sigma)) {
for (g in 1:length(gamma)) {
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond ="no-social"))
probs <- rbind(probs,data.frame(p = compute.probs2(gamma[g], lambda, sigma[s], numPic[n], int[i]),
trial.type = c("same","switch"),
int = int[i],
sigma = sigma[s],
gamma = gamma[g],
lambda = lambda,
numPic = numPic[n],
cond = "social"))
}
}
}
}
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==1.5)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
options(device="quartz")
qplot(x=int,y=p, linetype=trial.type,
colour=cond,
geom=c("line", "point"),
data=subset(probs, gamma==1.5)) +
facet_grid(sigma ~ numPic) +
ylim(0,1) +
xlab("Delay") +
ylab("Proportion Correct") +
theme_bw()
theta <- function(x,xdata,na.rm=T) {mean(xdata[x],na.rm=na.rm)}
ci.low <- function(x,na.rm=T) {
mean(x,na.rm=na.rm) - quantile(bootstrap(1:length(x),1000,theta,x,na.rm=na.rm)$thetastar,.025,na.rm=na.rm)}
ci.high <- function(x,na.rm=T) {
quantile(bootstrap(1:length(x),1000,theta,x,na.rm=na.rm)$thetastar,.975,na.rm=na.rm) - mean(x,na.rm=na.rm)}
?bootstrap()
library(bootstrap)
?bootstrap()
?quantile()
quantile(x <- rnorm(1001))
x
x <- rnorm(1000)
?rnorm()
theta
?aggregate()
